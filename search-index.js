var N=null,E="",T="t",U="u",searchIndex={};
var R=["string","result","cpp_include_walker","try_from","try_into","borrow_mut","borrow","type_id","typeid","children","ancestors","dependencynode","formatter","DependencyNode","DependencyForest","SimpleGraph"];

searchIndex["cpp_include_walker"]={"doc":E,"i":[[3,R[13],R[2],"A node in the dependency forest",N,N],[12,"key",E,"a unique identifier",0,N],[12,"path",E,"path to file, if it exists in the searched directory",0,N],[12,"used_by",E,"adjacency list (who depends on me)",0,N],[12,"uses",E,"adjacency list (who do I depend on)",0,N],[3,R[14],E,"A class that implements the dependency forest, i.e. a set…",N,N],[12,"directory",E,"The source directory",1,N],[12,"node_map",E,"a hash map of dependencies                       ",1,N],[5,"keyify",E,"keyify turns a path or a string to a somewhat unique key…",N,[[["p"]],[[R[0]],[R[1],[R[0],"str"]],["str"]]]],[0,"simple_graph",E,"simple graph functionality specially purposed for…",N,N],[8,R[15],"cpp_include_walker::simple_graph","A simple graph implementation on unordered borrowed data",N,N],[16,"N",E,"Node type",2,N],[10,"nodes",E,"get all nodes",2,[[["self"]],["vec"]]],[10,R[9],E,"get all children of a node",2,[[["self"]],["vec"]]],[11,R[10],E,"get all ancestors of a node",2,[[["self"]],["vec"]]],[11,"get_topological_order",E,"get topologically sorted vector of nodes for a graph",2,[[["self"]],[["str"],[R[1],["vec","str"]],["vec"]]]],[0,"file_io",R[2],"parse files recursively for `#include` statements",N,N],[5,"get_deps","cpp_include_walker::file_io","parse all dependencies of a cpp source or header file",N,[[["p"]],[[R[1],["vec","error"]],["error"],["vec",[R[0]]]]]],[5,"ls_apply",E,"recursively find all files and apply a function to the…",N,[[["bool"],["f"],["p"]]]],[11,"fill_from_directory",R[2],"fill the dependency forest from all header and source…",1,[[["bool"],["self"],["p"]]]],[11,"len",E,"returns number of nodes in the dependency forest",1,[[["self"]],["usize"]]],[11,"include_order",E,"get include order",1,[[["self"],["bool"]],[[R[1],["vec","str"]],["vec",[R[11]]],["str"]]]],[11,"into",E,E,0,[[],[U]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[3],E,E,0,[[[U]],[R[1]]]],[11,R[4],E,E,0,[[],[R[1]]]],[11,R[5],E,E,0,[[["self"]],[T]]],[11,R[6],E,E,0,[[["self"]],[T]]],[11,R[7],E,E,0,[[["self"]],[R[8]]]],[11,"into",E,E,1,[[],[U]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[3],E,E,1,[[[U]],[R[1]]]],[11,R[4],E,E,1,[[],[R[1]]]],[11,R[5],E,E,1,[[["self"]],[T]]],[11,R[6],E,E,1,[[["self"]],[T]]],[11,R[7],E,E,1,[[["self"]],[R[8]]]],[11,R[9],E,E,1,[[["self"]],["vec"]]],[11,R[10],E,E,1,[[["self"]],["vec"]]],[11,"nodes",E,E,1,[[["self"]],["vec"]]],[11,"default",E,E,0,[[],[R[11]]]],[11,"default",E,E,1,[[],["dependencyforest"]]],[11,"eq",E,E,0,[[["self"]],["bool"]]],[11,"fmt",E,E,0,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,1,[[["self"],[R[12]]],[R[1]]]]],"p":[[3,R[13]],[3,R[14]],[8,R[15]]]};
initSearch(searchIndex);addSearchOptions(searchIndex);